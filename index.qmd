---
title: "LQCD @ PASC23"
author: "Sam Foreman"
date: "2023-06-05"
format:
  revealjs:
    preview-links: true
    controls: false
    logo: "https://raw.githubusercontent.com/saforem2/anl-job-talk/main/docs/assets/anl.svg"
    history: false
    theme: [dark, custom.scss]
    css: [css/default.css, css/callouts.css]
    self-contained: false
    embed-resources: false
    self-contained-math: false
    center: true
    highlight-style: "atom-one"
    default-image-extension: svg
    code-line-numbers: true
    code-overflow: scroll
    html-math-method: katex
    fig-align: center
    execute:
      freeze: auto
---

# {.centeredslide background-iframe="https://saforem2.github.io/grid-worms-animation/" loading="lazy"}

::: {style="text-shadow: 0px 0px 10px RGBA(0, 0, 0, 0.45); background-color: rgba(22,22,22,0.88); border-radius: 10px; text-align:center; box-shadow:RGBA(0, 0, 0, 0.45) 0px 5px 15px; padding-top: 1em; padding-bottom: 1em;"}
<span style="color:#939393; font-size:1.5em; font-weight: bold; padding: 1pt 0pt;">Generative Modeling \& Efficient Sampling</span>

<span style="font-size:0.8em; color:#505050; padding:0px; margin:0px; text-align:center!important;">2023-06-29</span>  
<span style="font-size:0.8em; color:#505050; padding:0px; margin:0px; text-align:center!important;"> @ [PASC23](https://pasc23.pasc-conference.org/)</span>

[{{< fa solid home >}}](https://samforeman.me) Sam Foreman  
[{{< fa brands github >}} `saforem2/lqcd-pasc23`](https://github.com/saforem2/lqcd-pasc23)
:::

# Standard Model {auto-animate="true"}

:::: {.columns}

::: {.column width="60%"}
- <span class="yellow">{{< fa solid bolt >}}</span> Electricity & Magnetism <span class="red">{{< fa solid magnet >}}</span>
- <span class="purple">{{< fa solid atom >}}</span> Quantum Field Theory
  - Nuclear interactions
    - Strong + Weak Force
    - Observed particles
  - Quantum Chromodynamics (**QCD**):
    - Quark / gluon interactions in the nuclueus
    - Analytic progress is _difficult_...[^progress]
      - Lattice QCD to the rescue! üöÄ
:::

::: {.column width="40%"}
![](https://github.com/saforem2/physicsSeminar/raw/main/assets/static/nucleus.svg){.fragment .fade-down width="50%"}
![](https://github.com/saforem2/physicsSeminar/raw/main/assets/static/feynman.svg){.fragment .fade-up width="100%"}
:::

::::

[^progress]: Completely stalled ?
<!-- [![](https://github.com/saforem2/physicsSeminar/raw/main/assets/static/feynman.svg)](https://github.com/saforem2/physicsSeminar/raw/main/assets/static/feynman.svg) -->
<!-- <a href="https://github.com/saforem2/physicsSeminar/raw/main/assets/static/nucleus.svg"><img src="https://github.com/saforem2/physicsSeminar/raw/main/assets/static/nucleus.svg" width="50%" style="text-align:center;"></a>{.fragment .fade-down} -->

## {.centeredslide background-color="white"}

![](https://upload.wikimedia.org/wikipedia/commons/0/00/Standard_Model_of_Elementary_Particles.svg)

## {.centeredslide background-video="https://d2r55xnwy6nx47.cloudfront.net/uploads/2021/04/Muon_2560_Lede.mp4" background-video-loop="true" background-video-muted="true"}

::: {style="text-shadow: 0px 0px 10px black; background-color: rgba(22,22,22,0.33); border-radius: 10px; text-align:center; box-shadow:RGBA(0, 0, 0, 0.35) 0px 5px 15px; padding: 0px; padding-left: 1%; padding-right: 1%; max-width: min-content; min-width: max-content; margin-left: auto; margin-right: auto; padding-top: 1em;"}
<span style="font-size: 1.75em; font-weight: bold;">Magnetic Moment of the Muon</span>

::: {style="font-size: 1.5em; margin-top: 0pt; margin-bottom: 0pt; border:2px solid #00CCFF; border-radius:8px; margin-left:auto; margin-right:auto; min-width: max-content; max-width: min-content; padding-left: 1%; padding-right: 1%; background-color: rgba(22,22,22,0.5); "}
$a_{\mu} = \frac{(g_{\mu} - 2)}{2}$
:::

Can Lattice QCD resolve this?  
<span style="font-size:0.8em; color: var(--dim-color); padding-bottom: 1em;">new physics??</span>  

::: {.aside style="text-shadow: 0px 0px 10px black; text-align: center;"}
$\left(\delta a_{\mu}\right)^{\mathrm{exp}}_{\mathrm{th}} = 5.02 \times 10^{-9}$

:::

:::

## [Fermilab: Muon g-2](https://vms.fnal.gov/gallery/view?id=41) {style="top:0;"}

::: {.panel-tabset}

### The Ring

![](https://mod.fnal.gov/mod/stillphotos/2017/0100/17-0188-17.hr.jpg){width="80%" fig-align="center"}

### In Transit

![](https://mod.fnal.gov/mod/stillphotos/2013/0200/13-0235-18D.hr.jpg){width="80%" fig-align="center"}

### Arrival

![](https://mod.fnal.gov/mod/stillphotos/2013/0200/13-0244-11D.hr.jpg){width="80%" fig-align="center"}

:::

# Markov Chain Monte Carlo (MCMC)

:::: {.columns}

::: {.column width="50%"}

::: {.callout-note title="Goal" style="text-align:left;!important"}
Generate **independent** samples $\{x_{i}\}$, s.t.[^notation]
$$\{x_{i}\} \sim p(x) \propto e^{-S(x)}$$
:::

- Want to calculate observables $\mathcal{O}$:  
  $\left\langle \mathcal{O}\right\rangle \propto \int \left[\mathcal{D}x\right]\hspace{4pt} {\mathcal{O}(x) e^{-S[x]}}$

:::

::: {.column width="49%"}
![](https://raw.githubusercontent.com/saforem2/deep-fridays/main/assets/normal_distribution.dark.svg)
:::

::::

If configurations were <span style="color:#00CCFF;">independent</span>, we could approximate[^approx]
  $$
  \left\langle\mathcal{O}\right\rangle \textcolor{#00CCFF}{\simeq} \frac{1}{N}\sum^{N}_{n=1}\mathcal{O}(x_{n})%
  \quad \textcolor{#00CCFF}{\Longrightarrow} \quad \sigma_{\mathcal{O}}^{2} = \frac{1}{N}\mathrm{Var}{\left[\mathcal{O} (x) \right]}%
  $$

[^notation]: Here, $\sim$ means "is distributed according to"
[^target]: Here, $S(x)$ is the action (~ potential energy) of our physical system
[^approx]: Our variance on this estimator is then $\sigma_{\mathcal{O}}^{2}$

# Hamiltonian Monte Carlo (HMC) {.centeredslide}

- Want to (sequentially) construct a chain of states $\\{x_{i}\\}$,
  such that  as $N \rightarrow \infty$:
  $$\begin{equation*}
  \left\{x_{0}, x_{1}, x_{2}, \cdots, x_{N} \right\} \longrightarrow p(x) \propto e^{-S(x)}
  \end{equation*}$$

::: {.callout-caution title="Trick" style="display:inline!important;"}
  - Introduce _fictitious_ momentum $v \sim \mathcal{N}(0, \mathbb{1})$
  - Normally distributed **independent** of $x$, i.e.
  $$\begin{align*}
  	p(x)p(v) &\propto e^{-S{(x)}} e^{-\frac{1}{2} v^{T}v}\\
   	&= e^{-\left[S(x) + \frac{1}{2} v^{T}{v}\right]} \\
   	&\textcolor{#FD971F}{=} e^{-H(x, v)}
  \end{align*}$$
:::

# Hamiltonian Monte Carlo (HMC) {.centeredslide}

:::: {.columns}

::: {.column width="55%"}

- <span style="color:#66bb6a; font-weight: bold;">Idea</span>: Evolve the $(\dot{x}, \dot{v})$ system to get new states $\{x_{i}\}$‚ùó
- Write the **joint distribution** $p(x, v)$:
  $$
  p(x, v) \propto e^{-S[x]} e^{-\frac{1}{2}v^{T} v} = e^{-H(x, v)}
  $$
:::

::: {.column width="45%"}

::: {.callout-tip title="Hamiltonian Dynamics"}
$H = S[x] + \frac{1}{2} v^{T} v \Longrightarrow$
$$\dot{x} = +\partial_{v} H,
\hspace{20pt} \dot{v} = -\partial_{x} H$$
:::

:::

::::

![](https://raw.githubusercontent.com/saforem2/deep-fridays/main/assets/hmc1.svg)

# Leapfrog Integrator (HMC)

:::: {.columns}

::: {.column width="50%" style="text-align: center;"}

::: {.callout-important title="Hamiltonian Dynamics"}
$\left(\dot{x}, \dot{v}\right) = \left(\partial_{v} H, -\partial_{x} H\right)$
:::

::: {.callout-note title="Leapfrog Step"}

[input]{.dim-text style="font-family:monospace;"} $\,\left(x_{0}, v_{0}\right) \rightarrow \left(x', v'\right)\,$ [output]{.dim-text style="font-family:monospace;"}

<!-- 1. $v_{0} \sim {\mathcal{N}(0, \mathbb{1})}\hspace{76px}$ [\# resample $v$]{.dim-text style="font-family:monospace"} -->
<!-- 1. [update $\textcolor{#B2F2BB}{v}\quad$]{style="font-family:monospace"} -->
$v_{1} := \textcolor{#FFD8A8}{\Gamma}(x_{0}; v_{0}) = v_{0} - \frac{\varepsilon}{2} \partial_{x} S(x_{0})\hspace{3px}$

<!-- 2. [update $\textcolor{#D0BFFF}{x}$]{style="font-family:monospace"} -->
$x' := \textcolor{#99E9F2}{\Lambda}(x_{0}; v_{1}) = x_{0} + \varepsilon \, v_{1}\hspace{29px}$

<!-- 3. [update $\textcolor{#B2F2BB}{v}$]{style="font-family:monospace"} -->
$v' := \textcolor{#FFD8A8}{\Gamma}(x'; v_{1}) = v_{1} - \frac{\varepsilon}{2} \partial_{x} S(x')\hspace{8px}$ 

::: {.callout-warning title="Warning!"}
$v_{0} \sim \mathcal{N}(0, \mathbb{1})$ at the _beginning_ of each trajectory
:::

:::

:::

::: {.column width="49%"}
![](./assets/hmc-vertical-light.svg)
:::

::::

[^eps]: Of step size $\varepsilon$

::: {.aside}
**Note**: The gradient of the action, $\partial_{x} S(x)$ is called the _force_
:::


# HMC Update

:::: {.columns}

::: {.column width="65%"}
- We build a trajectory of $N_{\mathrm{LF}}$ **leapfrog steps**[^v0]
  $$\begin{equation*}
  (x_{0}, v_{0})%
  \rightarrow (x_{1}, v_{1})\rightarrow \cdots%
  \rightarrow (x', v')
  \end{equation*}$$

- And propose $x'$ as the next state in our chain
<!-- - which is _accepted_ (or rejected) via Metroplis-Hastings[^accept] -->
<!-- - $x'$ is proposed with probability $A(x'|x)$[^accept] -->
<!-- - Use $x'$ as our proposal in the Metropolis-Hastings accept / reject, $A(x'|x)$ -->

$$\begin{align*}
  \textcolor{#FFD8A8}{\Gamma}: (x, v) \textcolor{#FFD8A8}{\rightarrow} v' &:= v - \frac{\varepsilon}{2} \partial_{x} S(x) \\
  \textcolor{#99E9F2}{\Lambda}: (x, v) \textcolor{#99E9F2}{\rightarrow} x' &:= x + \varepsilon v
\end{align*}$$

- We then accept / reject $x'$ using Metropolis-Hastings criteria,  
  $A(x'|x) = \min\left\{1, \frac{p(x')}{p(x)}\left|\frac{\partial x'}{\partial x}\right|\right\}$
:::

::: {.column width="34%"}
![](./assets/hmc-vertical-light.svg)
:::

::::

[^v0]: 
    We **always** start by resampling the momentum,
    $v_{0} \sim \mathcal{N}(0, \mathbb{1})$

# {.centeredslide}

<section data-background-iframe="https://chi-feng.github.io/mcmc-demo/app.html"
          data-background-interactive>
</section>

# Issues with HMC

- What do we want in a good sampler?
  - **Fast mixing** (small autocorrelations)
  - **Fast burn-in** (quick convergence)

- Problems with HMC:
  - Energy levels selected randomly $\rightarrow$ **slow mixing**
  - Cannot easily traverse low-density zones $\rightarrow$ **slow convergence**

::: {layout-ncol=2}
![](https://raw.githubusercontent.com/saforem2/l2hmc-dwq25/main/docs/assets/hmc_traj_eps025.svg)

![](https://raw.githubusercontent.com/saforem2/l2hmc-dwq25/main/docs/assets/hmc_traj_eps05.svg)
:::

# Links + References

- This talk: [{{< fa brands github >}} `saforem2/lqcd-pasc23`](https://github.com/saforem2/lqcd-pasc23)
- Code repo [{{< fa brands github >}} `saforem2/l2hmc-qcd`](https://github.com/saforem2/l2hmc-qcd)
- Slides [{{< fa solid presentation-screen >}} saforem2.github.io/lqcd-pasc23](https://saforem2.github.io/lqcd-pasc23)

- [Animated background](https://www.quantamagazine.org/last-hope-experiment-finds-evidence-for-unknown-particles-20210407/)

- [Fermilab Muon g-2](https://muon-g-2.fnal.gov/index.html)

# Thank you!


# Extras

## Python

```{python}
#| code-fold: true
#| echo: true
import numpy as np
x = np.random.rand()
print(x)
```

::: {.notes}
Speaker notes go here.
:::

## Columns

:::: {.columns}

::: {.column width="40%"}
Left column
:::

::: {.column width="60%"}
Right column
:::

::::

## Python {.scrollable}

For a demonstration of a line plot on a polar axis, see @fig-polar

```{python}
#| label: fig-polar
#| fig-cap: "A line plot on a polar axis"
#| echo: true
#| code-fold: false
#| output-location: slide
import numpy as np
import matplotlib.pyplot as plt

plt.rcParams.update({
    'axes.facecolor': 'none',
    'figure.facecolor': 'none',
    'savefig.facecolor': 'none',
    'savefig.format': 'svg',
    'axes.edgecolor': 'none',
    'axes.grid': True,
    'axes.labelcolor': '#666',
    'axes.titlecolor': '#666',
    'grid.color': '#666',
    'text.color': '#666',
    'grid.linestyle': '--',
    'grid.linewidth': 0.5,
    'grid.alpha': 0.4,
    'xtick.color': 'none',
    'ytick.color': 'none',
    'xtick.labelcolor': '#666',
    'legend.edgecolor': 'none',
    'ytick.labelcolor': '#666',
    'savefig.transparent': True,
})

r = np.arange(0, 2, 0.01)
theta = 2 * np.pi * r
fix, ax = plt.subplots(
    subplot_kw = {'projection': 'polar'}
)
assert isinstance(ax, plt.PolarAxes)
ax.plot(theta, r)
ax.set_rticks([0.5, 1., 1.5, 2.])
ax.grid(True)
plt.show()
```

## Figures with Subcaptions

```{python}
#| label: fig-charts
#| echo: true
#| fig-cap: "Charts"
#| fig-subcap: 
#|   - "First"
#|   - "Second"
#| layout-ncol: 2

import matplotlib.pyplot as plt
plt.plot([1,23,2,4])
plt.show()

plt.plot([8,65,23,90])
plt.show()
```

## Mermaid Diagrams

```{mermaid}
flowchart TB
  A --> C
  A --> D
  B --> C
  B --> D
```

## Mermaid Example

```{mermaid}
flowchart LR
  markdown["`This **is** _Markdown_`"]
  newLines["`Line1
  Line 2
  Line 3`"]
  markdown --> newLines
```

## Model Parallel Training: Example

$$y = w_0 * x_0 + w_1 * x_1 + w_2 * x_2$$

1. Compute $y_{0} = w_{0} * x_{0}$ and send to $\longrightarrow$ `GPU1`
2. Compute $y_{1} = y_{0} + w_{1} * x_{1}$ and send to $\longrightarrow$ `GPU2`
3. Compute $y = y_{1} * w_{2} * x_{2}$ ‚úÖ


```{mermaid}
%%{init: { "theme": "dark", "fontFamily": "monospace", "logLevel": "debug", "deterministicIds": true, "flowchart": { "htmlLabels": true}, "sequence": { "mirrorActors": true } } }%%
flowchart LR
  subgraph X0["GPU0"]
    direction LR
    a["w0"]
  end
  subgraph X1["GPU1"]
    direction LR
    b["w1"]
  end
  subgraph X2["GPU2"]
    direction LR
    c["w2"]
  end
  X1 & X0 <--> X2
  X0 <--> X1
  x["x0, x1, x2"] --> X0
```


## Block Layout

::: {layout-ncol=2}
### List One

- Item A
- Item B
- Item C

### List Two

- Item X
- Item Y
- Item Z
:::

## Placing Colorbars {.scrollable}

Colorbars indicate the quantitative extent of image data.
Placing in a figure is non-trivial because room needs to
be made for them. The simplest case is just attaching a 
colorbar to each axes:

```{python}
#| label: fig-colorbars
#| echo: true
#| output-location: slide
import matplotlib.pyplot as plt
import numpy as np

fig, axs = plt.subplots(2, 2)
assert isinstance(fig, plt.Figure)
cmaps = ['RdBu_r', 'viridis']
for col in range(2):
    for row in range(2):
        ax = axs[row, col]
        pcm = ax.pcolormesh(
          np.random.random((20, 20)) * (col + 1),
          cmap=cmaps[col]
        )
        fig.colorbar(pcm, ax=ax)
ax.grid(False)
plt.show()
```

## Testing Callouts

::: {.callout-note title="Note"}
Testing note callouts with `default` appearance
:::

::: {.callout-tip title="Tip"}
Testing tip callout with `default` appearance
:::

::: {.callout-caution title="Caution"}
Testing tip callout with `default` appearance
:::

::: {.callout-warning title="Warning"}
Testing warning callout with `default` appearance
:::

::: {.callout-important title="Important"}
Testing important callout with `default` appearance
:::

# Testing Markdown

- Testing lists
- Testing
  - Testing
  - Testing again
    - triple Checkboxes
  - Nested lists
    - [ ] TODOs
    - [x] Checkboxes ??

## Extras (+ other callouts)

:::: {.bs-callout .bs-callout-default}
::: {.callout-title}
Default
:::
Note that there are six types of callouts, including:
`default`, `primary`, `success`, `info`, and `warning`, and `danger`
::::

:::: {.bs-callout .bs-callout-primary}
::: {.callout-title}
Primary
:::
::::

:::: {.bs-callout .bs-callout-info}
::: {.callout-title}
Info
:::
::::


::: {.bs-callout .bs-callout-success}
::: {.callout-title}
Success
:::
::::

:::: {.bs-callout .bs-callout-warning}
::: {.callout-title}
Warning!
:::
::::

:::: {.bs-callout .bs-callout-danger}
::: {.callout-title}
Danger!
:::
::::
